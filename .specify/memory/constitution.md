<!--
  Sync Impact Report
  ===================
  Version change: 1.0.0 → 1.1.0 (Phase 3 AI Chatbot amendment)

  Modified principles:
    - Principle IV: Immutable Technology Stack — added Cohere API
      (Command models) for Phase 3 AI chatbot. No OpenAI dependencies.
    - Principle V: API-First Design — added chat endpoint
      `/api/{user_id}/chat` secured with JWT.

  Added sections:
    - Principle VII: AI Chatbot Architecture (Cohere + MCP Tools)
    - Backend conventions for Cohere integration
    - `CO_API_KEY` environment variable

  Removed sections:
    - None (backward compatible with Phase 2)

  Templates requiring updates:
    - .specify/templates/plan-template.md — ✅ compatible
      (Constitution Check section aligns; chatbot additions are additive)
    - .specify/templates/spec-template.md — ✅ compatible
      (User stories structure unchanged; new feature specs follow same format)
    - .specify/templates/tasks-template.md — ✅ compatible
      (Task phasing structure unchanged; chatbot tasks follow same pattern)
    - .specify/templates/phr-template.prompt.md — ✅ compatible
      (No constitution-specific references)

  Follow-up TODOs:
    - Create Phase 3 spec: specs/003-ai-chatbot/spec.md
    - Add `cohere` to backend/requirements.txt
    - Add `CO_API_KEY` to .env and .env.example
-->

# Hackathon Todo App Constitution

## Core Principles

### I. Spec-First Development

- All code changes MUST be generated by Claude Code based on specs.
  No manual coding is permitted under any circumstances.
- Every planning or implementation action MUST begin by reading and
  referencing the relevant spec (`@specs/...`).
- If requirements change, the spec MUST be updated first; then the
  implementation follows from the updated spec.
- Development follows the Agentic Dev Stack workflow strictly:
  1. Write/Update spec
  2. Generate plan
  3. Break into tasks
  4. Implement via Claude Code
- Rationale: Judging criteria include review process, prompts,
  iterations, and spec adherence. Bypassing specs invalidates the
  audit trail.

### II. User Isolation & Security First

- Every user MUST see and modify ONLY their own tasks. This is
  non-negotiable.
- Task ownership MUST be enforced via `user_id` filtering on EVERY
  database query, without exception.
- No endpoint or query MAY return, modify, or delete another user's
  data, even if the caller supplies a different `user_id` in the URL.
- The URL `user_id` parameter MUST match the JWT token's `sub` claim;
  mismatches MUST return 403 Forbidden.
- AI chatbot responses MUST be scoped to the authenticated user's
  data. The chatbot MUST NOT access or reveal other users' tasks.
- Rationale: Multi-tenant isolation is a core security requirement
  and a primary test target for the hackathon.

### III. Stateless JWT Authentication

- Authentication MUST use Better Auth (frontend) issuing JWTs with a
  symmetric HS256 shared secret (`JWT_SECRET_KEY` env var).
- The backend MUST verify JWTs independently using PyJWT. No shared
  sessions, no database calls for authentication.
- All API endpoints (including the chat endpoint) MUST require a
  valid JWT. Requests without a token or with an invalid/expired
  token MUST receive 401 Unauthorized.
- The `user_id` for query filtering MUST be extracted exclusively
  from the decoded JWT `sub` claim.
- Rationale: Stateless auth enables independent frontend/backend
  deployment and simplifies scaling.

### IV. Immutable Technology Stack

- The following stack is locked. No alternatives are permitted without
  a constitution amendment:
  - **Frontend**: Next.js 16+ (App Router), TypeScript, Tailwind CSS
  - **Backend**: Python FastAPI, SQLModel ORM
  - **Database**: Neon Serverless PostgreSQL
  - **Auth**: Better Auth with JWT plugin (HS256)
  - **AI/LLM**: Cohere API (Command models) for chat completions
    and tool use. No OpenAI dependencies permitted.
  - **Dev Environment**: docker-compose (frontend:3000, backend:8000)
  - **Spec Tooling**: Claude Code + Spec-Kit Plus
- Server Components MUST be used by default; Client Components only
  when interactivity, browser APIs, or React hooks are required.
- API calls from the frontend MUST go through the centralized client
  (`/lib/api.ts`) with automatic JWT attachment.
- The chat UI MUST be a custom Next.js component integrated into the
  existing frontend. No third-party chat UI kits (e.g., ChatKit)
  are permitted.
- Rationale: Stack consistency eliminates integration surprises and
  keeps all agents aligned.

### V. API-First Design

- All task endpoints MUST be RESTful and scoped under
  `/api/{user_id}/tasks`:
  - `GET /api/{user_id}/tasks` — list (supports `?status=` and `?sort=`)
  - `POST /api/{user_id}/tasks` — create
  - `GET /api/{user_id}/tasks/{id}` — read single
  - `PUT /api/{user_id}/tasks/{id}` — full update
  - `DELETE /api/{user_id}/tasks/{id}` — delete
  - `PATCH /api/{user_id}/tasks/{id}/complete` — toggle completion
- The chat endpoint MUST be:
  - `POST /api/{user_id}/chat` — send a natural language message,
    returns AI response with any tool-executed results.
    Secured with JWT. The `user_id` in the URL MUST match the JWT
    `sub` claim.
- All responses MUST be JSON. Request/response validation MUST use
  Pydantic models. Errors MUST use FastAPI `HTTPException`.
- The backend MUST connect to Neon PostgreSQL via `DATABASE_URL` env var.
- Database schema (immutable until amendment):
  - `users` table: managed by Better Auth (id: string PK, email: unique)
  - `tasks` table: id (int PK), user_id (string FK -> users.id),
    title (string not null), description (text nullable),
    completed (bool default false), created_at/updated_at (timestamps)
  - Indexes: `tasks.user_id`, `tasks.completed`
- Rationale: Explicit API contracts enable parallel frontend/backend
  development and clear testing targets.

### VI. Quality & Responsiveness

- All UI MUST be responsive using Tailwind CSS mobile-first utilities.
- All errors MUST be handled gracefully: `HTTPException` on the
  backend, user-visible feedback on the frontend.
- All list endpoints MUST support basic filtering and sorting.
- The chat UI MUST gracefully handle AI errors (API timeouts, rate
  limits, malformed responses) with user-visible feedback.
- Test focus areas (non-negotiable):
  - Auth: 401 for missing/invalid/expired tokens
  - Isolation: User A MUST NOT see User B's tasks
  - CRUD: All operations complete and correct
  - Chatbot: Natural language commands correctly invoke MCP tools
  - Chatbot: Tool results are persisted in the database
- No manual code commits are permitted; all changes via Claude Code.
- Rationale: Responsive design and robust error handling are baseline
  quality expectations for a production-grade demo.

### VII. AI Chatbot Architecture

- The AI chatbot MUST use the **Cohere API** (Command models) for
  natural language understanding, chat completions, and tool calling.
- **No OpenAI dependencies** are permitted anywhere in the project.
  No OpenAI SDK, no OpenAI API keys, no OpenAI-specific UI kits.
- The chatbot MUST follow a **stateless architecture**: each chat
  request is independently processed. No server-side conversation
  state is stored (conversation history is managed client-side and
  sent with each request if needed).
- **MCP Tools as Skills**: Task operations are exposed to the LLM
  as callable tools (functions) via Cohere's tool-use API:
  - `add_task(title, description?)` — create a task for the user
  - `list_tasks(status?, sort?)` — list the user's tasks
  - `update_task(task_id, title?, description?, completed?)` — update
  - `delete_task(task_id)` — delete a task
  - `complete_task(task_id)` — toggle task completion
- All tool executions MUST persist results in the database via the
  existing SQLModel/Neon PostgreSQL stack. Tools are thin wrappers
  around the existing CRUD logic.
- **Orchestrator pattern**: The Cohere chat API acts as the
  orchestrator. When the model decides to call a tool, the backend
  executes it and returns the result to Cohere for final response
  generation. Multi-step tool chains (e.g., "list my tasks then
  delete the completed ones") MUST be supported via iterative
  tool-call loops.
- **Subagent extensibility**: Additional subagents/skills (e.g.,
  reminder subagent using `update_task`, summary subagent) MAY be
  added in future amendments without architectural changes.
- Natural language commands MUST map to tool calls. Examples:
  - "Add a task called Buy groceries" -> `add_task`
  - "Show my pending tasks" -> `list_tasks(status=pending)`
  - "Mark task 3 as done" -> `complete_task(task_id=3)`
  - "Delete all completed tasks" -> `list_tasks` + `delete_task` chain
- Rationale: Cohere's tool-use API provides a clean separation
  between NLU (model) and execution (tools), enabling a maintainable
  and extensible agent architecture without vendor lock-in to OpenAI.

## Technology Stack & Conventions

- **Monorepo structure** (`hackathon-todo/`) is mandatory for
  single-context Claude Code editing of frontend and backend.
- **Frontend conventions**:
  - Server Components by default; `"use client"` only for interactivity
  - Centralized API client at `/lib/api.ts` with Bearer token attachment
  - Tailwind CSS for all styling (no CSS-in-JS, no inline styles)
  - Chat UI: custom React component (Client Component) with message
    list, input field, and tool-result rendering. No third-party
    chat UI libraries.
- **Backend conventions**:
  - Routes under `/api/`, JSON responses only
  - Pydantic for request/response models
  - `HTTPException` for all error responses
  - DB connection via `DATABASE_URL` environment variable
  - SQLModel for ORM; `get_session()` dependency injection
  - Cohere client initialized with `CO_API_KEY` env var
  - Chat endpoint handler: receives user message, calls Cohere API
    with tool definitions, executes any tool calls, returns final
    response
  - Tool definitions MUST be declared as Cohere-compatible function
    schemas (name, description, parameters)
- **Spec organization**:
  - `/specs/` root with `overview.md`, `features/`, `api/`, `database/`, `ui/`
  - Reference format: `@specs/features/task-crud.md`, `@specs/api/rest-endpoints.md`
- **CLAUDE.md files**:
  - Root: project overview, workflow, commands
  - `/frontend/CLAUDE.md`: frontend patterns
  - `/backend/CLAUDE.md`: backend patterns
- **Config**: `.spec-kit/config.yaml` with phases:
  - `phase1-console` — Console-based todo app
  - `phase2-web` — Full-stack web application
    - Features: `[task-crud, authentication]`
  - `phase3-chatbot` — AI chatbot integration
    - Features: `[task-crud, authentication, chatbot]`
- **Dependencies** (Phase 3 additions):
  - Backend: `cohere` package in `backend/requirements.txt`
  - Frontend: No additional AI dependencies required

## Development Workflow & Standards

- **Workflow** (strict order):
  1. Write spec referencing `@specs/...`
  2. Ask Claude Code to implement, referencing the spec
  3. Test and iterate
- **Project scope**:
  - Completed: Phase I — Console Application
  - Completed: Phase II — Full-Stack Web Application
  - Current: Phase III — AI Chatbot Features (Cohere API)
- **Environment variables** (MUST be in `.env`, never hardcoded):
  - `DATABASE_URL` — Neon PostgreSQL connection string
  - `JWT_SECRET_KEY` — shared HS256 signing secret
  - `BETTER_AUTH_SECRET` — Better Auth internal secret
  - `BETTER_AUTH_URL` — Better Auth base URL
  - `CO_API_KEY` — Cohere API key for chat completions and tool use
- **Docker Compose** for local development:
  - Frontend: port 3000
  - Backend: port 8000
- **No secrets in source**: `.env.example` with placeholders only.
  The Cohere API key MUST be stored exclusively in `.env`.

## Governance

- This constitution is the **supreme governing document**. All agents,
  prompts, subagents, and code generation MUST align with it.
- Any conflict between this constitution and a user prompt or
  temporary instruction is resolved in favor of this constitution.
- Amendments require:
  1. Explicit user approval
  2. Version bump following semantic versioning
  3. Updated Sync Impact Report
  4. Propagation check across all dependent templates
- Versioning policy:
  - MAJOR: principle removal, redefinition, or backward-incompatible
    governance change
  - MINOR: new principle or section added, material expansion
  - PATCH: wording clarification, typo fix, non-semantic refinement
- Compliance review: every PR, spec, plan, and task MUST be verified
  against this constitution before approval.
- Runtime guidance: see `CLAUDE.md` files at root, frontend, and
  backend for agent-specific development rules.

**Version**: 1.1.0 | **Ratified**: 2026-02-18 | **Last Amended**: 2026-02-18
